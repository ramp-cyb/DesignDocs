<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Strangler Pattern & TDD Migration Guide - SimplCommerce Microservices</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <nav class="main-nav">
        <a href="MigrationAnalysis.html">Analysis</a>
        <a href="MigrationPlan.html">Migration Plan</a>
        <a href="DesignOverview.html">Design Overview</a>
        <a href="ExecutionPlan.html">Execution Plan</a>
        <a href="DependencyGraph.html">Dependency Graph</a>
        <a href="MigrationExamples.html">Migration Examples</a>
        <a href="StranglerTDD.html">Strangler & TDD Guide</a>
    </nav>
    <div class="container">
        <h1>Strangler Pattern, Anti-Corruption Layer & TDD Migration Guide</h1>
        <h2>1. Strangler Pattern for Microservices Migration</h2>
        <p>The <b>Strangler Pattern</b> enables incremental migration from a monolith to microservices by routing new or refactored functionality to microservices, while legacy code continues to run in the monolith. Over time, the monolith is "strangled" as more features are migrated.</p>
        <h3>Detailed Example: Side-by-Side Operation & Data Handling</h3>
        <ol>
            <li><b>Initial State:</b> All order creation and queries are handled by the monolith. Data is stored only in the monolith's database.</li>
            <li><b>Step 1: Introduce API Gateway/Router</b><br>
                - The API Gateway inspects incoming requests.<br>
                - For <code>POST /orders</code>, it can route to either the monolith or the new Order microservice based on feature toggles, user segments, or other rules.
            </li>
            <li><b>Step 2: Dual Writes (Transition Phase)</b><br>
                - For a period, order creation requests are sent to both the monolith and the microservice.<br>
                - <b>Data Handling:</b> Both systems insert the order. To avoid duplication:
                <ul>
                    <li>Use a shared unique order ID (generated by the gateway or a central service).</li>
                    <li>Mark records with a migration flag or source system indicator.</li>
                </ul>
                - <b>Consistency:</b> Use events or change data capture to synchronize updates between systems. If an order is updated in one, publish an event to update the other.
            </li>
            <li><b>Step 3: Read Redirection & Data Synchronization</b><br>
                - <code>GET /orders/{id}</code> requests are routed to the microservice if the order exists there, otherwise to the monolith.<br>
                - Periodic background jobs or event-driven sync ensure both systems have up-to-date data.
            </li>
            <li><b>Step 4: Cutover & Cleanup</b><br>
                - Once confidence is high, all writes and reads are routed to the microservice.<br>
                - The monolith's order logic is deprecated and eventually removed.<br>
                - Data is fully migrated, and duplication is resolved by reconciling records and removing legacy data.
            </li>
        </ol>
        <h4>Key Considerations</h4>
        <ul>
            <li><b>Data Duplication:</b> Acceptable temporarily. Use unique IDs and migration flags to prevent conflicts.</li>
            <li><b>Consistency:</b> Use events, CDC, or background sync to keep both systems in sync. Accept eventual consistency during migration.</li>
            <li><b>Conflict Resolution:</b> Define clear rules for which system is the source of truth during each phase.</li>
            <li><b>Rollback:</b> If issues arise, route all traffic back to the monolith and reconcile data as needed.</li>
        </ul>
        <h4>Illustrative Flow</h4>
        <pre><code>// API Gateway Routing (pseudo-code)
if (featureToggle.NewOrderServiceEnabled) {
    // Write to both systems (dual write)
    monolith.CreateOrder(order);
    microservice.CreateOrder(order);
} else {
    monolith.CreateOrder(order);
}

// Read logic
if (microservice.HasOrder(orderId)) {
    return microservice.GetOrder(orderId);
} else {
    return monolith.GetOrder(orderId);
}
</code></pre>
        <div class="note"><b>Summary:</b> The strangler pattern allows safe, incremental migration. During the transition, both systems may write/read data. Use unique IDs, events, and sync jobs to manage duplication and consistency. Cut over fully to the microservice when stable.</div>

        <h2>2. Anti-Corruption Layer (ACL)</h2>
        <p>An <b>Anti-Corruption Layer</b> protects new microservices from legacy models and logic. It translates between monolith and microservice contracts, ensuring clean boundaries.</p>
        <h3>Example: ACL Implementation</h3>
        <pre><code class="language-csharp">// In Order Microservice
public class MonolithOrderAcl {
    private readonly HttpClient _monolithClient;
    public MonolithOrderAcl(HttpClient monolithClient) {
        _monolithClient = monolithClient;
    }
    public async Task&lt;OrderDto&gt; GetOrderFromMonolith(int orderId) {
        var resp = await _monolithClient.GetAsync($"/legacy/orders/{orderId}");
        var legacyOrder = await resp.Content.ReadAsAsync<LegacyOrderDto>();
        // Map legacyOrder to new OrderDto
        return MapToOrderDto(legacyOrder);
    }
}
</code></pre>
        <ul>
            <li>All translation logic is isolated in the ACL.</li>
            <li>Prevents legacy data models from leaking into new services.</li>
        </ul>

        <h2>3. TDD: Unit & Integration Test Scripts for APIs</h2>
        <p>All new APIs must be developed using Test-Driven Development (TDD). Below is a comprehensive list of unit test cases and API integration test scripts, organized by microservice/area, to ensure full contract and scenario coverage.</p>

        <h3>Unit Test Cases by Area</h3>
        <table class="table">
            <tr><th>Area / Microservice</th><th>Test Case Name</th><th>Description</th></tr>
            <tr><td rowspan="6">Order Service</td><td>Should_CreateOrder_When_StockIsAvailable</td><td>Creates an order when product stock is sufficient.</td></tr>
            <tr><td>Should_RejectOrder_When_StockIsInsufficient</td><td>Rejects order if requested quantity exceeds available stock.</td></tr>
            <tr><td>Should_EmitOrderCreatedEvent_OnSuccess</td><td>Emits an OrderCreated event after successful order creation.</td></tr>
            <tr><td>Should_ValidateOrderInput</td><td>Validates order input for required fields and constraints.</td></tr>
            <tr><td>Should_HandleCatalogServiceFailure</td><td>Handles errors when Catalog service is unavailable or returns error.</td></tr>
            <tr><td>Should_ApplyDiscount_When_ValidCouponProvided</td><td>Applies discount to order total when a valid coupon is used.</td></tr>
            <tr><td rowspan="5">Catalog Service</td><td>Should_ReturnProductDetails_When_ProductExists</td><td>Returns product details for a valid product ID.</td></tr>
            <tr><td>Should_ReturnNotFound_When_ProductDoesNotExist</td><td>Returns 404 when product ID is invalid.</td></tr>
            <tr><td>Should_CreateProduct_When_ValidInput</td><td>Creates a new product with valid input data.</td></tr>
            <tr><td>Should_RejectProductCreation_When_InvalidInput</td><td>Rejects product creation if input data is invalid.</td></tr>
            <tr><td>Should_UpdateProductStock_OnStockEvent</td><td>Updates product stock when a stock event is received.</td></tr>
            <tr><td rowspan="4">Inventory Service</td><td>Should_DecrementStock_When_OrderPlaced</td><td>Decrements stock when an order is placed.</td></tr>
            <tr><td>Should_RejectStockUpdate_When_InsufficientStock</td><td>Rejects stock update if not enough stock is available.</td></tr>
            <tr><td>Should_EmitStockUpdatedEvent_OnSuccess</td><td>Emits StockUpdated event after successful stock update.</td></tr>
            <tr><td>Should_HandleOrderCreatedEvent</td><td>Handles OrderCreated event and updates stock accordingly.</td></tr>
            <tr><td rowspan="4">Payment Service</td><td>Should_ProcessPayment_When_ValidOrder</td><td>Processes payment for a valid order.</td></tr>
            <tr><td>Should_RejectPayment_When_InvalidOrder</td><td>Rejects payment if order is invalid or already paid.</td></tr>
            <tr><td>Should_EmitPaymentProcessedEvent_OnSuccess</td><td>Emits PaymentProcessed event after successful payment.</td></tr>
            <tr><td>Should_HandleOrderPaidEvent</td><td>Handles OrderPaid event and updates payment status.</td></tr>
            <tr><td rowspan="3">WishList Service</td><td>Should_AddItemToWishList_When_Valid</td><td>Adds an item to the wishlist for a valid user and product.</td></tr>
            <tr><td>Should_RemoveItemFromWishList_When_Exists</td><td>Removes an item from the wishlist if it exists.</td></tr>
            <tr><td>Should_EmitWishListChangedEvent_OnChange</td><td>Emits WishListChanged event when wishlist is updated.</td></tr>
            <tr><td rowspan="3">Content Service</td><td>Should_CreatePage_When_ValidInput</td><td>Creates a new content page with valid input.</td></tr>
            <tr><td>Should_RejectPageCreation_When_InvalidInput</td><td>Rejects page creation if input is invalid.</td></tr>
            <tr><td>Should_EmitContentEvent_OnPageChange</td><td>Emits ContentChanged event when a page is created or updated.</td></tr>
            <tr><td rowspan="3">Shipping Service</td><td>Should_CreateShipment_When_OrderIsReady</td><td>Creates a shipment for a ready order.</td></tr>
            <tr><td>Should_RejectShipment_When_OrderNotReady</td><td>Rejects shipment creation if order is not ready.</td></tr>
            <tr><td>Should_EmitShipmentEvent_OnShipment</td><td>Emits ShipmentCreated event after shipment is created.</td></tr>
        </table>

        <h3>API Integration Test Scripts (End-to-End Scenarios)</h3>
        <table class="table">
            <tr><th>Script Name</th><th>Endpoints Covered</th><th>Scenario Description</th></tr>
            <tr><td>Order Placement E2E</td><td>POST /api/orders, GET /api/orders/{id}, GET /api/products/{id}</td><td>Places an order, verifies order creation, checks product stock is decremented.</td></tr>
            <tr><td>Order Payment Flow</td><td>POST /api/orders, POST /api/payments, GET /api/payments/{orderId}</td><td>Places an order, processes payment, verifies payment status and order update.</td></tr>
            <tr><td>Inventory Update on Order</td><td>POST /api/orders, GET /api/inventory/{productId}</td><td>Places an order and verifies inventory is updated accordingly.</td></tr>
            <tr><td>WishList Add/Remove</td><td>POST /api/wishlists, DELETE /api/wishlists/{itemId}, GET /api/wishlists/{userId}</td><td>Adds and removes items from wishlist, verifies changes.</td></tr>
            <tr><td>Content Page Creation</td><td>POST /api/pages, GET /api/pages/{id}</td><td>Creates a content page and retrieves it to verify content.</td></tr>
            <tr><td>Shipping Workflow</td><td>POST /api/orders, POST /api/shipments, GET /api/shipments/{orderId}</td><td>Places an order, creates a shipment, verifies shipment status.</td></tr>
            <tr><td>Catalog Product CRUD</td><td>POST /api/products, GET /api/products/{id}, PUT /api/products/{id}, DELETE /api/products/{id}</td><td>Creates, updates, retrieves, and deletes a product, verifying each step.</td></tr>
        </table>

        <h3>API Contract Coverage</h3>
        <ul>
            <li>All endpoints and business scenarios must have corresponding unit and integration tests before implementation is considered complete.</li>
            <li>Integration test scripts should be versioned and run in CI/CD pipelines, using PowerShell or other automation tools.</li>
            <li>Use TDD: Write tests first, then implement API logic. Update this list as new endpoints and scenarios are added.</li>
        </ul>
        <div class="note">This page is a living guide for migration using the strangler pattern, ACLs, and TDD. Update as new APIs and contracts are added.</div>
    </div>
</body>
</html>
